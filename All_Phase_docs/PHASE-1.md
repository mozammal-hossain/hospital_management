# Phase-1: ভিত্তি ও প্রজেক্ট স্ট্রাকচার

**সময়:** প্রায় ২ ঘণ্টা  
**স্টাইল:** গল্প বলার ভঙ্গিতে, টিউটর মোড — শুধু বোঝা, কোড নয়।

---

## একটু পটভূমি

তুমি যদি Flutter দিয়ে অ্যাপ বানিয়ে থাকো, তাহলে জানো — একটা প্রজেক্ট শুরু করার সময় আমরা প্রথমেই একটা কাঠামো গড়ে তুলি। যেমন: `lib/` এর ভেতরে `models/`, `services/`, `screens/` ইত্যাদি ফোল্ডার। .NET এও একই ধারণা: **প্রথমে ভিত্তি সাজানো**, তারপর একটু একটু করে জিনিস যোগ করা।

Phase-1 এ আমরা ঠিক সেটাই করব — কোনো API এন্ডপয়েন্ট বানাব না, শুধু **মডেল**, **ডেটা ঢোকার/আপডেটের ফর্মের মতো জিনিস (DTO)**, আর **সার্ভিসের ইন্টারফেস** দিয়ে প্রজেক্টের হাড়গোড় গড়ে তুলব। শেষে একটা **রানযোগ্য অ্যাপ** থাকবে যেখানে Dependency Injection (DI) সেট আপ থাকবে; এন্ডপয়েন্ট আসবে Phase-3–৪ এ।

---

## Phase-1 এ কী কী করতে হবে (সংক্ষেপে)

১. **ফোল্ডার স্ট্রাকচার** — `Models/` আর `Services/` ফোল্ডার তৈরি করা।  
২. **Patient এনটিটি** — হাসপাতালের রোগীর ডেটা কেমন হবে সেটা একটা ক্লাস/মডেলে ঠিক করা।  
৩. **দুইটা DTO** — একটা **Create** (নতুন রোগী ঢুকানোর সময় কী কী ফিল্ড পাঠাব), আর একটা **Update** (আপডেটের সময় কী কী পাঠাব)।  
৪. **DI রেজিস্ট্রেশন** — `Program.cs` এ বলে দেওয়া যে `IPatientRepository` চাইলে আসলে `PatientRepository` দেবে (এ Phase এ Repository ইমপ্লিমেন্ট করব না, শুধু ইন্টারফেস/স্টাব রাখব)।

নিচে প্রতিটা ধাপ Flutter এর সাথে মিলিয়ে সহজভাবে বর্ণনা করা হলো।

---

## ১. ফোল্ডার স্ট্রাকচার (Models, Services)

**কী করবে:**  
প্রজেক্ট রুটে দুটো ফোল্ডার বানাবে: `Models/` আর `Services/`.

**Flutter এর সাথে তুলনা:**  
Flutter এ আমরা যেমন `lib/models/`, `lib/services/` বা `lib/repositories/` রাখি — যেখানে মডেল ক্লাস, রিপোজিটরি ইন্টারফেস/ইমপ্লিমেন্টেশন থাকে — .NET এও একই ধারণা। `Models/` = ডেটার আকৃতি (এনটিটি + DTO), `Services/` = যেসব সার্ভিস ডেটা নিয়ে কাজ করবে (এখানে রিপোজিটরি)। ফোল্ডার স্ট্রাকচার Phase-1 এ ঠিক করলে পরের ফেজগুলোতে ফাইল খুঁজে পেতে সুবিধা হবে।

---

## ২. Patient এনটিটি (Models/Patient.cs)

**কী করবে:**  
একটা `Patient` ক্লাস (বা রেকর্ড) বানাবে যেখানে নিচের ফিল্ডগুলো থাকবে:

- **Id** — ইউনিক আইডি (পরবর্তীতে Guid বা int দিয়ে জেনারেট করবে)
- **FullName** — রোগীর পুরো নাম
- **DateOfBirth** — জন্মতারিখ
- **Gender** — লিঙ্গ
- **PhoneNumber** — ফোন নম্বর
- **Email** — ইমেইল
- **AdmittedAt?** — কখন ভর্তি হয়েছে (ঐচ্ছিক; তাই `?` বা nullable)
- **IsDischarged** — ডিসচার্জ হয়েছে কিনা (হ্যাঁ/না)

**Flutter এর সাথে তুলনা:**  
Flutter এ আমরা যেমন `class Patient { ... }` দিয়ে মডেল বানাই এবং কখনো `fromJson` / `toJson` লিখি — .NET এ `Patient` হলো সেই “এনটিটি” ক্লাস। পরে JSON সিরিয়ালাইজেশন ASP.NET Core নিজে করে দেবে, আলাদা করে `toJson` লিখতে হয় না। `AdmittedAt?` মানে “ঐচ্ছিক” — Dart এর `DateTime?` এর মতো।

**মনে রাখো:**  
এটা হলো **ডেটাবেস/মেমোরিতে থাকা আসল অবজেক্টের আকৃতি**। API দিয়ে বাইরে কী পাঠাব বা ক্লায়েন্ট কী পাঠাবে, সেটা DTO দিয়ে নিয়ন্ত্রণ করবে।

---

## ৩. DTO দুটো: CreatePatientRequest ও UpdatePatientRequest

**কী করবে:**  
দুইটা আলাদা ক্লাস/রেকর্ড বানাবে:

- **CreatePatientRequest** — যখন কেউ **নতুন রোগী যোগ** করতে `POST /patients` করবে, বডিতে যে ফিল্ডগুলো পাঠাবে শুধু সেগুলো এখানে থাকবে। সাধারণত Id থাকবে না (সার্ভার জেনারেট করবে); AdmittedAt, IsDischarged ইত্যাদি প্রয়োজনমতো থাকতে পারে।
- **UpdatePatientRequest** — যখন কেউ **আপডেট** করতে `PUT /patients/{id}` করবে, বডিতে যে ফিল্ডগুলো পাঠাবে (যেগুলো বদলাতে চায়) সেগুলো এখানে। Id সাধারণত বডিতে না রেখে URL এর `{id}` দিয়ে পাঠানো হয়।

**Flutter এর সাথে তুলনা:**  
Flutter এ আমরা অনেক সময় আলাদা “request model” বা “input model” রাখি — যেমন `CreateUserInput`, `UpdateProfileRequest` — যেখানে শুধু সেই অপারেশনের জন্য দরকারি ফিল্ড থাকে। Create আর Update এ অনেক সময় ফিল্ড সেট আলাদা হয় (যেমন Create এ Id নেই, Update এ হয়তো শুধু কয়েকটা ফিল্ড পাঠাই)। .NET এও DTO = সেই রিকোয়েস্ট বডির “আকৃতি”; পরে Phase-3/৪ এ আমরা এই DTO তে JSON বাইন্ড করব।

**কেন আলাদা DTO?**  
এনটিটি (`Patient`) আর রিকোয়েস্ট (Create/Update) আলাদা রাখলে: (১) ক্লায়েন্ট শুধু দরকারি ফিল্ড পাঠায়, (২) ভবিষ্যতে ভ্যালিডেশন (যেমন Required, Email ফরম্যাট) DTO তে দিলেই হয়, (৩) এনটিটি ইন্টারনাল রাখা যায়, API কন্ট্রাক্ট পরিষ্কার থাকে।

---

## ৪. ইন্টারফেস: IPatientRepository (Services/)

**কী করবে:**  
`Services/` এ একটা ইন্টারফেস বানাবে নাম `IPatientRepository`। Phase-1 এ এটাকে **খালি বা স্টাব** রাখতে পারো — মানে ভেতরে মেথড সাইনেচার লিখে রাখবে (GetAll, GetById, Add, Update, Delete) কিন্তু ইমপ্লিমেন্ট করবে Phase-2 এ। উদ্দেশ্য: Phase-1 এ শুধু “এই নামে একটা সার্ভিস থাকবে” বলে DI এ রেজিস্টার করা।

**Flutter এর সাথে তুলনা:**  
Flutter/Dart এ আমরা `abstract class PatientRepository { ... }` বা ইন্টারফেস লিখে তারপর `class ApiPatientRepository implements PatientRepository` লিখি। .NET এ `interface IPatientRepository` = সেই একই চুক্তি। পরবর্তীতে `PatientRepository` ক্লাস এই ইন্টারফেস ইমপ্লিমেন্ট করবে (Phase-2)। Phase-1 এ শুধু ইন্টারফেসটা থাকলেই হয়; রিপোজিটরি ইমপ্লিমেন্টেশন Phase-2 এর কাজ।

---

## ৫. Program.cs এ DI রেজিস্ট্রেশন

**কী করবে:**  
`Program.cs` এ বলবে: যখন কেউ `IPatientRepository` চাইবে, তখন যেন `PatientRepository` দেয়। কিন্তু Phase-1 এ `PatientRepository` ক্লাস এখনো বানাওনি — তাই হয় তুমি একটা **খালি/স্টাব ইমপ্লিমেন্টেশন** বানাবে শুধু কম্পাইল হওয়ার জন্য, নয়তো Phase-1 এর ডেলিভারেবল অনুযায়ী “ইন্টারফেস প্রস্তুত রাখা” পর্যন্তই রাখবে এবং Phase-2 এ এসে আসল রিপোজিটরি যোগ করে `AddScoped<IPatientRepository, PatientRepository>()` লিখবে।

ডকুমেন্ট অনুযায়ী Phase-1 এর ডেলিভারেবল: _“Program.cs — builder.Services.AddScoped<IPatientRepository, PatientRepository>() (interface prepared for Phase 2).”_ অর্থাৎ ইন্টারফেসটা প্রস্তুত; রিপোজিটরি ক্লাস Phase-2 এ আসবে। তাই Phase-1 এ তুমি হয় একটা ছোট্ট স্টাব ক্লাস লিখে `AddScoped<IPatientRepository, PatientRepository>()` দিতে পারো, নয়তো শুধু কমেন্ট/নোট রেখে Phase-2 এ পূর্ণ রেজিস্ট্রেশন করবে। টিউটরিয়াল হিসেবে: **Phase-1 এ ফোকাস রাখো মডেল + DTO + ফোল্ডার + ইন্টারফেসে; DI রেজিস্ট্রেশনটা Phase-2 এ রিপোজিটরি বানানোর সাথে একসাথে পরিষ্কার করলেও চলে।** যদি চাও যে অ্যাপ রান করলে যেন কোনো error না আসে, তাহলে একটা খালি ইমপ্লিমেন্টেশন (যে মেথডগুলো throw করবে বা খালি রিটার্ন করবে) দিয়ে `AddScoped` করে দিতে পারো।

**Flutter এর সাথে তুলনা:**  
Flutter এ আমরা `get_it` বা `Provider` দিয়ে রিপোজিটরি রেজিস্টার করি: `getIt.registerSingleton<PatientRepository>(...)`। .NET এ `builder.Services.AddScoped<IPatientRepository, PatientRepository>()` একই ধারণা — “সার্ভিস কন্টেইনার” জানবে কে কী দেবে। Scoped মানে একটা রিকোয়েস্টের জন্য একই ইনস্ট্যান্স; ওয়েব API এর জন্য এটাই সাধারণ।

---

## Phase-1 শেষে কী থাকবে (চোখে দেখার মতো)

- **প্রজেক্ট রুটে:**

  - `Models/` — ভেতরে `Patient.cs`, `CreatePatientRequest.cs`, `UpdatePatientRequest.cs`
  - `Services/` — ভেতরে `IPatientRepository.cs` (এবং চাইলে স্টাবের জন্য একটা ছোট `PatientRepository.cs`)

- **Program.cs:**

  - অ্যাপ বিল্ড, OpenAPI ইত্যাদি যেমন আছে; সাথে `IPatientRepository` (এবং যদি স্টাব থাকলে `PatientRepository`) রেজিস্ট্রেশন — যাতে পরবর্তী ফেজে এন্ডপয়েন্ট লিখলে রিপোজিটরি ইনজেক্ট করতে পারো।

- **চলবে:**
  - `dotnet run` দিয়ে অ্যাপ রান হবে; এখনো `/patients` এন্ডপয়েন্ট থাকবে না, শুধু ভিত্তি (মডেল, DTO, ফোল্ডার, DI প্রস্তুতি) থাকবে।

---

## Flutter vs .NET — Phase-1 এক নজরে

| ধারণা                  | Flutter / Dart                 | .NET / C# (Phase-1)                                 |
| ---------------------- | ------------------------------ | --------------------------------------------------- |
| মডেল ক্লাস             | `class Patient { ... }`        | `class Patient` বা `record Patient`                 |
| রিকোয়েস্ট বডির আকৃতি  | আলাদা input/request ক্লাস      | DTO: `CreatePatientRequest`, `UpdatePatientRequest` |
| রিপোজিটরি চুক্তি       | `abstract class` / `interface` | `interface IPatientRepository`                      |
| রিপোজিটরি রেজিস্ট্রেশন | `get_it` / Provider            | `builder.Services.AddScoped<...>()`                 |
| ফোল্ডার                | `lib/models/`, `lib/services/` | `Models/`, `Services/`                              |
| ঐচ্ছিক ফিল্ড           | `DateTime?`                    | `DateTime?` বা nullable রেফারেন্স টাইপ              |

---

## ছোট উপদেশ (টিউটর থেকে)

- একসাথে সব করো না; প্রথমে ফোল্ডার, তারপর Patient, তারপর দুটো DTO, তারপর ইন্টারফেস, শেষে Program.cs — এভাবে ধাপে ধাপে করলে মাথা ঠান্ডা থাকবে।
- DTO আর Entity আলাদা রাখার অভ্যাসটা Flutter এ যেমন ভালো, .NET এও একই রকম গুরুত্বপূর্ণ।
- Phase-1 এ এন্ডপয়েন্ট বা ডেটাবেস নিয়ে চিন্তা করো না — শুধু “কাঠামো” আর “ডেটার আকৃতি” ঠিক করো।

Phase-2 এ আমরা এই কাঠামোর ওপর ভর দিয়ে **ইন-মেমোরি রিপোজিটরি** বানাব — তখন `GetAll`, `GetById`, `Add`, `Update`, `Delete` এর ভেতরে লজিক লিখবে।  
শুভকামনা।
